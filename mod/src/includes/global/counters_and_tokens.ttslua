function getAccelerationCounter(params)
    local createIfNotFound = params.createIfNotFound or false
    local overridePosition = params.overridePosition or nil
    local allObjects = getAllObjects()

    for _, obj in ipairs(allObjects) do
        if obj.hasTag("counter") and obj.hasTag("acceleration") then
            return obj
        end
    end

    if(not createIfNotFound) then
        return nil
    end

    local accelerationCounterPosition = overridePosition

    if(accelerationCounterPosition == nil) then
        local mainSchemeThreatCounter = getMainSchemeThreatCounter()

        if(mainSchemeThreatCounter == nil) then
            broadcastToAll("No main scheme threat counter found. Cannot create acceleration token.", {1, 0, 0})
            return nil
        end
    
        local threatCounterPosition = mainSchemeThreatCounter.getPosition()
        accelerationCounterPosition = threatCounterPosition + Vector(2.5, 0, 2.5)    
    end

    local accelerationCounterBag = getObjectFromGUID(Global.getVar("GUID_ACCELERATION_COUNTER_BAG"))
    local accelerationCounter = accelerationCounterBag.takeObject(
        {
            position = accelerationCounterPosition, 
            smooth = false,
            callback_function=function(obj)
                obj.setScale({0.5, 1.00, 0.5})
                obj.setLock(true)
            end
        })

    return accelerationCounter
end

function getMainSchemeThreatCounter(params)
    local allObjects = getAllObjects()

    for _, obj in ipairs(allObjects) do
        --TODO: this assumes that there will only be one main scheme threat counter; need to make it more robust
        if obj.hasTag("counter") and obj.hasTag("threat") and obj.hasTag("main-scheme") then
            return obj
        end
    end

    return nil
end

function getCounterFromCard(params)
    local card = params.card
    local counterClass = params.counterClass or "standard"
    local counterGuid = getCardValue({cardGuid = card.getGUID(), property = counterClass .. "CounterGuid"})
    local counter = counterGuid and getObjectFromGUID(counterGuid) or nil

    return counter
end

function removeCountersFromCard(params)
  local card = params.card
  local cardGuid = card.getGUID()
  local cardValues = getAllCardValues({cardGuid = cardGuid})

  if(not cardValues) then return end
  local counterClasses = {"standard", "configured"}

  for _, counterClass in ipairs(counterClasses) do
    local counterGuid = cardValues[counterClass .. "CounterGuid"]
    if (counterGuid) then
      local counter = nil
      
      Wait.condition(
        function()
          Wait.frames(
            function()
              local value = counter.call("getValue")
              setCardValue({cardGuid = cardGuid, property = counterClass .. "RetainedValue", value = value})

              counter.destruct()
          end, 1)
        end,
        function()
          counter = getObjectFromGUID(counterGuid)
          return counter ~= nil
        end,
        3,
        function()
          setCardValue({cardGuid = cardGuid, property = counterClass .. "CounterGuid", value = nil})
        end
      )
    end
  end
end

function calculateSideSchemeThreat(params)
  local cardData = params.cardData
  local heroCount = params.heroCount
  local threat = 0

  local baseThreat = cardData.baseThreat and tonumber(cardData.baseThreat) or 0
  local baseThreatIsFixed = cardData.baseThreatIsFixed == "true"
  local hinder = cardData.hinder and tonumber(cardData.hinder) or 0
 
  if baseThreatIsFixed then
    threat = baseThreat + (heroCount * hinder)
  else
    threat = baseThreat * heroCount
  end  

  return threat
end

function calculateMinionHealth(params)
  local cardData = params.cardData
  local heroCount = params.heroCount
  local health = 0

  if(cardData.healthPerHero) then
    health = cardData.health * heroCount
  else
    health = cardData.health
  end  

  return health
end

function calculateAllyHealth(params)
  local cardData = params.cardData
  return cardData.health or 0
end

function addCountersAndTokensToCard(params)
  local card = params.card

  Wait.condition(function()
      if (card.isDestroyed()) then
        return
      end

      Wait.frames(function()         
        addStandardCounterToCard(params)
        addConfiguredCounterToCard(params)

        if (card.hasTag("toughness")) then
            addStatusToMinionOrAlly({
                card = card,
                statusType = "tough"
            })
        end
      end, 15)
    end, function()
        return card.isDestroyed() or card.resting
    end, 3)
end

function addStandardCounterToCard(params)
  local card = params.card

  local counterGuid = getCardValue({cardGuid = card.getGUID(), property = "standardCounterGuid"})
  if(counterGuid and getObjectFromGUID(counterGuid)) then return end

  local cardData = params.cardData or getCardData({card = card})
  if(not cardData) then return end

  local value = 0
  local valueCalcFunction = ""
  local retainedValue = getCardValue({cardGuid = card.getGUID(), property = "standardRetainedValue"})
  local valueOverride = getCardValue({cardGuid = card.getGUID(), property = "standardCounterValueOverride"})
  local baseOffsetOverride = getCardValue({cardGuid = card.getGUID(), property = "standardCounterBaseOffset"})
  local counterType = ""
  local cardType = cardData.type
  local baseScale
  local baseOffset

  if(cardType == "side_scheme" or cardType == "player_side_scheme") then
    counterType = "threat"
    valueCalcFunction = "calculateSideSchemeThreat"
    baseScale = {0.4, 1.00, 0.4}
    baseOffset = {-0.6, 0.10, -0.7}
  elseif(cardType == "ally") then
    counterType = "health"
    valueCalcFunction = "calculateAllyHealth"
    baseScale = {0.2, 1.00, 0.2}
    baseOffset = {0.90, 0.10, -0.35}
  elseif(cardType == "minion") then
    counterType = "health"
    valueCalcFunction = "calculateMinionHealth"
    baseScale = {0.2, 1.00, 0.2}
    baseOffset = {0.9, 0.10, -0.2}
  else
    return
  end

  if(retainedValue) then
      value = retainedValue
  else
    value = valueOverride 
    or _G[valueCalcFunction]({
      cardData = cardData,
      heroCount = getObjectFromGUID(GUID_HERO_MANAGER).call("getHeroCount")
    })
  end

  addCounterToCard({
    card = card, 
    counterClass = "standard", 
    counterType = counterType, 
    counterName = "", 
    value = value, 
    baseScale = baseScale, 
    baseOffset = baseOffsetOverride or baseOffset
  })
end

function addConfiguredCounterToCard(params)
  local card = params.card

  local counterGuid = getCardValue({cardGuid = card.getGUID(), property = "configuredCounterGuid"})
  if(counterGuid and getObjectFromGUID(counterGuid)) then return end

  local cardData = params.cardData or getCardData({card = card})
  if(not cardData or not cardData.counter) then return end

  local value = 0
  local retainedValue = getCardValue({cardGuid = card.getGUID(), property = "configuredRetainedValue"})

  if(retainedValue) then
      value = retainedValue
  else
    local baseValue = cardData.counterValue and tonumber(cardData.counterValue) or 0
    local valuePerHero = cardData.counterValuePerHero and tonumber(cardData.counterValuePerHero) or 0
    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local heroCount = heroManager.call("getHeroCount")
    value = baseValue + (heroCount * valuePerHero)
  end
  addCounterToCard({
    card = card, 
    counterClass = "configured", 
    counterType = cardData.counter, 
    counterName = cardData.counterName, 
    value = value
  })
end

function addCounterToCard(params)
  local card = params.card
  local counterClass = params.counterClass
  local counterType = params.counterType
  local counterName = params.counterName or ""
  local counterBag
  local baseScale
  local baseOffset
  local value = params.value or 0

  if(counterType == "threat") then
      counterBag = getObjectFromGUID(GUID_THREAT_COUNTER_BAG)
      baseScale = params.baseScale or {0.4, 1.00, 0.4}
      baseOffset = params.baseOffset or {0, 0.10, 0.65}
  elseif(counterType == "general") then
      counterBag = getObjectFromGUID(GUID_GENERAL_COUNTER_BAG)
      baseScale = params.baseScale or {0.3, 1.00, 0.3}
      baseOffset = params.baseOffset or {0, 0.10, 0.55}
  elseif(counterType == "health") then
      counterBag = getObjectFromGUID(GUID_HEALTH_COUNTER_BAG)
      baseScale = params.baseScale or {0.3, 1.00, 0.3}
      baseOffset = params.baseOffset or {0, 0.10, 0.75}
  end

  local playerCardScale = Global.getTable("CARD_SCALE_PLAYER")
  local cardScale = card.getScale()
  local scaleFactor = cardScale[1] / playerCardScale[1]
  local counterScale = Vector({baseScale[1] * scaleFactor, baseScale[2], baseScale[3] * scaleFactor})
  local offset = Vector({baseOffset[1] * scaleFactor, baseOffset[2] * scaleFactor, baseOffset[3] * scaleFactor})
  local cardPosition = card.getPosition()
  local counterPosition = Vector({cardPosition[1] + offset[1], cardPosition[2] + offset[2], cardPosition[3] + offset[3]})
  local counter = counterBag.takeObject(
    {
      position = counterPosition, 
      smooth = false,
      callback_function=function(obj)
        Wait.frames(function() 
          obj.setScale(counterScale)
          obj.setName(counterName)
          obj.call("setValue", {value = value})
        end, 
        1)
      end
    })
    setCardValue({cardGuid = card.getGUID(), property = counterClass .. "CounterGuid", value = counter.getGUID()})
end

function addStatusToVillain(params)
    local villain = params.villain
    local statusType = params.statusType
    local villainCard = getObjectFromGUID(villain.cardGuid)
  
    if not cardCanHaveStatus({card = villainCard, statusType = statusType}) then
      return
    end
  
    placeStatusToken({card = villainCard, statusType = statusType})
end
  
function addStatusToMinionOrAlly(params)
    local card = params.card
    local statusType = params.statusType
  
    if not cardCanHaveStatus({card = card, statusType = statusType}) then
      return
    end
  
    placeStatusToken({card = card, statusType = statusType})
end

function addStatusToAllHeroes(params)
    local statusType = params.statusType
    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local heroes = heroManager.call("getSelectedHeroes")
  
    for color, _ in pairs(heroes) do
      addStatusToHero({playerColor = color, statusType = statusType})
    end
end

function addStatusToHero(params)
    local playerColor = params.playerColor
    local statusType = params.statusType
    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local hero = heroManager.call("getHeroByPlayerColor", {playerColor = playerColor})
    local heroCard = getObjectFromGUID(hero.identityGuid)
  
    if not cardCanHaveStatus({card = heroCard, statusType = statusType}) then
      return
    end
  
    placeStatusToken({card = heroCard, statusType = statusType, playerColor = playerColor})
end

function cardCanHaveStatus(params)
    local card = params.card
    local cardPosition = card.getPosition()
    local cardName = card.getName()
    local targetType = Global.call("getCardProperty", {card = card, property = "type"})
    local statusType = params.statusType
  
    statusCount = getStatusCount({card = card, statusType = statusType})
  
    local playerColor = getCardValue({cardGuid = card.getGUID(), property = "playerColor"})
    local messageType = playerColor and MESSAGE_TYPE_PLAYER or MESSAGE_TYPE_INFO
 
    if(statusType == "tough") then
      local maxToughCount = (targetType == "hero" and cardName == "Colossus") and 2 or 1
      if(statusCount >= maxToughCount) then
        displayMessage({message = cardName .. " is already tough.", messageType = messageType, playerColor = playerColor})
        return false
      end
    else
      if(card.hasTag("stalwart")) then
        displayMessage({message = cardName .. " is stalwart and cannot be " .. statusType .. ".", messageType = messageType, playerColor = playerColor})
        return false
      end
      
      local maxStatusCount = card.hasTag("steady") and 2 or 1
  
      if(statusCount >= maxStatusCount) then
        displayMessage({message = cardName .. " is already " .. statusType .. ".\n(If there is an effect in play that makes this character steady, please give them a second " .. statusType .. " card manually.)", messageType = messageType, playerColor = playerColor})
        return false
      end
    end
  
    return true
end

function getStatusCount(params)
    local card = params.card
    local statusType = params.statusType
    local items = getItemsOnCard({card = card})
    local statusCount = 0
 
    for _, item in ipairs(items) do
       if item.hasTag(statusType.."-status") then
         statusCount = statusCount + 1
       end
    end
 
    return statusCount
end
  
function placeStatusToken(params)
    local card = params.card
    local statusType = params.statusType
  
    local baseScale = {0.4, 1, 0.4}
    local baseOffset = {0.2, 0.10, 0.9} 
    local playerCardScale = Global.getTable("CARD_SCALE_PLAYER")
    local cardScale = card.getScale()
    local scaleFactor = cardScale[1] / playerCardScale[1]
    local tokenScale = Vector({baseScale[1] * scaleFactor, baseScale[2], baseScale[3] * scaleFactor})
    local offset = Vector({baseOffset[1] * scaleFactor, baseOffset[2], baseOffset[3] * scaleFactor})
    local cardPosition = card.getPosition()
    local tokenPosition = Vector({cardPosition[1] + offset[1], cardPosition[2] + offset[2], cardPosition[3] + offset[3]})

    local statusBagGuid = 
      statusType == "tough" and "35b809"
      or statusType == "stunned" and "882e12"
      or statusType == "confused" and "50c501"
  
    local statusBag = getObjectFromGUID(statusBagGuid)
    local statusToken = statusBag.takeObject({
      position = {0, -5, 0},
      callback_function=function(obj)
        Wait.frames(function() 
          obj.setScale(tokenScale)
          obj.setPosition(tokenPosition, false, false)
        end, 
        1)
      end
    })
  
    local message = card.getName() .. " is " .. statusType .. "!"
  
    if(statusType == "stunned" or statusType == "confused") then
      message = message .. "\n(If there is an effect in play that makes this character steady, they may need another status card to actually be " .. statusType .. ".\nIf they are stalwart, you may need to remove this status card.)"
    end

    local playerColor = params.playerColor or getCardValue({cardGuid = card.getGUID(), property = "playerColor"})
    local messageType = playerColor and MESSAGE_TYPE_PLAYER or MESSAGE_TYPE_INFO
 
    displayMessage({message = message, messageType = messageType, playerColor = playerColor})
end

function rotateCountersWithCard(params)
  local card = params.card
  local spin = params.spin
  local oldSpin = params.oldSpin

  if (not isCard(card)) then return end
  if (spin == oldSpin) then return end

  local cardPosition = card.getPosition()
  local spinDelta = oldSpin - spin
  if(spinDelta > 180) then spinDelta = spinDelta - 360 end
  if(spinDelta < -180) then spinDelta = spinDelta + 360 end
  if(spinDelta == -180) then spinDelta = 180 end
  local counterClasses = {"standard", "configured"}

  for _, counterClass in ipairs(counterClasses) do
    local counterGuid = getCardValue({cardGuid = card.getGUID(), property = counterClass .. "CounterGuid"})
    if(counterGuid) then
      local counter = getObjectFromGUID(counterGuid)
      if(counter) then
        local counterPosition = counter.getPosition()
        local offset = counterPosition - cardPosition
        local radians = math.rad(spinDelta)
        local cosTheta = math.cos(radians)
        local sinTheta = math.sin(radians)
        local rotatedOffset = Vector(
          offset.x * cosTheta - offset.z * sinTheta,
          offset.y,
          offset.x * sinTheta + offset.z * cosTheta
        )
        counter.setPosition(cardPosition + rotatedOffset, false, false)
      end
    end
  end
end